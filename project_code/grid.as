package {	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix;	import flash.geom.Point;	/**	     *	     * 	     */	[SWF(width = "465",height = "465",frameRate = "60",backgroundColor = "0x333333")]	public class grid extends Sprite	{		private var test:Sprite;		private var lines:Sprite;		private var _pont:Point;		private var Arrays:Array;		private var SQ:Array;		private var diff:Number;		private var radian:Number;		private var diffPoint:Point;		private var Reaction:uint = 75;		private var spring:Number = 0.3;		private var friction:Number = 0.68;		private var gridSize:int=10;		public function grid():void		{			if (stage)			{				init();			}			else			{				addEventListener(Event.ADDED_TO_STAGE, init);			}		}		private function init(e:Event = null):void		{			removeEventListener(Event.ADDED_TO_STAGE, init);			// entry point			Arrays = [];			SQ = [];			for (var i:int = 0; i < gridSize; i++)			{				for (var j:int = 0; j < gridSize; j++)				{					var _point:Points = new Points(50 * i, 50 * j);					Arrays.push(_point);					var test:Sprite = addChild(new Sprite()) as Sprite;					test.graphics.beginFill(0xffffff);					test.graphics.drawCircle(0, 0, 3);					test.graphics.endFill();					SQ.push(test);				}			}			lines = addChild(new Sprite()) as Sprite;			addEventListener(Event.ENTER_FRAME, enter);		}		private function enter(e:Event):void		{			var mousePoint:Point = new Point(mouseX,mouseY);			var i:int;			for each (var _point:Points in Arrays)			{				_point.update(mousePoint,  Reaction, spring, friction);				SQ[i].x = _point.x;				SQ[i].y = _point.y;				i++;			}			lines.graphics.clear();			lines.graphics.lineStyle(1, 0xffffff, 1);			for (var n:int = 0; n < (gridSize*gridSize); n++)			{				lines.graphics.beginFill(0xffffff,distance/75);				lines.graphics.moveTo(SQ[n].x, SQ[n].y);				var distance:Number = Point.distance(mousePoint,new Point(SQ[n].x + 47,SQ[n].y + 47));				if (n < 90)				{					lines.graphics.lineTo( SQ[(n + gridSize)].x, SQ[n + gridSize].y);					if (n%gridSize)					{						lines.graphics.lineTo( SQ[(n + (gridSize-1) )].x, SQ[n + (gridSize-1)].y);						lines.graphics.lineTo( SQ[(n - 1 )].x, SQ[n - 1].y);					}					if (n==2||n==1)					{						lines.graphics.lineTo( SQ[(n-1)].x, SQ[n - 1].y);						lines.graphics.lineTo(SQ[n].x, SQ[n].y);					}				}			}			lines.graphics.endFill();		}	}}  import flash.geom.Point;class Points { 	private var localX:Number;	private var localY:Number;	private var vx:Number = 0;	private var vy:Number = 0;	private var _x:Number;	private var _y:Number;	public function Points(x:Number, y:Number)	{		_x = localX = x;		_y = localY = y;	}	public function update(mousePoint:Point, Reaction:uint, spring:Number, friction:Number):void	{		var dx:Number;		var dy:Number;		var distance:Number = Point.distance(mousePoint,new Point(localX,localY));		if (distance < Reaction)		{			var diff:Number = distance * -1 * (Reaction - distance) / Reaction;			var radian:Number = Math.atan2(mousePoint.y - localY,mousePoint.x - localX);			var diffPoint:Point = Point.polar(diff,radian);			dx = localX + diffPoint.x;			dy = localY + diffPoint.y;		}		else		{			dx = localX;			dy = localY;		}		vx +=  (dx - _x) * spring;		vy +=  (dy - _y) * spring;		vx *=  friction;		vy *=  friction;		_x +=  vx;		_y +=  vy;	}	public function get x():Number	{		return _x;	}	public function get y():Number	{		return _y;	}}